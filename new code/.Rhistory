function (..., list = character(), package = NULL, lib.loc = NULL,
verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE)
library(readxl)
rm(list=ls())
library(readxl)
data <- read_excel("C:/UPenn/academics/4 spring 2025/mktg 4760/homework/class prep due 1-14 (churn forecasting)/Churn forecasting data.xlsx")
colnames(data) <- c("year", "number", "perc_alive")
# test linear model
linear_model <- lm(perc_alive ~ year, data = data)
summary(linear_model)
# test exponential model (using nonlinear least squares)
exp_model <- nls(perc_alive ~ a * exp(b * year), data = data, start = list(a = 1000, b = -0.1))
summary(exp_model)
# test logistic model
logistic_model <- nls(perc_alive ~ L / (1 + exp(-k * (year - x0))), data = data, start = list(L = 100, k = 0.5, x0 = 0.5))
summary(exp_model)
# project to t = 12 using exponential model
future_years <- 0:12
exp_pred <- predict(exp_model, newdata = data.frame(year = future_years))
projected_data <- data.frame(year = future_years, perc_alive = exp_pred)
print(projected_data)
View(data)
write.csv(projected_data, "projected_data.csv")
write.csv(projected_data, "C:/UPenn/academics/4 spring 2025/mktg 4760/homework/class prep due 1-14 (churn forecasting)/projected_data.csv")
View(exp_model)
View(projected_data)
0.2564274 * 1000
rm(list=ls())
library(readxl)
data <- read_excel("C:/UPenn/academics/4 spring 2025/mktg 4760/homework/class prep due 1-14 (churn forecasting)/Churn forecasting data.xlsx")
colnames(data) <- c("year", "number", "perc_alive")
# test linear model
linear_model <- lm(perc_alive ~ year, data = data)
summary(linear_model)
# test exponential model (using nonlinear least squares)
exp_model <- nls(perc_alive ~ a * exp(b * year), data = data, start = list(a = 1000, b = -0.1))
summary(exp_model)
# project to t = 12 using exponential model
future_years <- 0:12
exp_pred <- predict(exp_model, newdata = data.frame(year = future_years))
projected_data <- data.frame(year = future_years, perc_alive = exp_pred)
projected_data
0.2564274 * 1000
## clear environment (if desired)
rm(list=ls())
function (..., list = character(), package = NULL, lib.loc = NULL,
verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE)
library(ggplot2)
# Define the "mother wavelet" H(t)
H <- function(t) {
if (t >= 0 && t < 0.5) {
return(1)
} else if (t >= 0.5 && t <= 1) {
return(-1)
} else {
return(0)
}
}
# Define the sequence of functions H_n(t)
H_n <- function(t, j, k) {
return(2^(j/2) * H((2^j) * t - k))
}
# Plotting function
plot_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Plot the mother wavelet
plot(t_vals, sapply(t_vals, H), type = "l", col = "blue", xlab = "t", ylab = "H(t)",
main = paste("Mother Wavelet and H_n(t) for n = 0 to", n_max))
lines(t_vals, sapply(t_vals, H), col = "blue")
# Plot the wavelets H_n(t) for n = 1 to n_max
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
lines(t_vals, sapply(t_vals, H_n, j = j, k = k), col = "red")
}
}
# Example: Plot H_n(t) for n from 1 to 8
plot_wavelets(8)
# Plotting function
plot_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Set up colors (a different color for each wavelet)
colors <- rainbow(n_max) # Generate a set of colors
labels <- c("Mother Wavelet") # Label for the mother wavelet
# Plot the mother wavelet
plot(t_vals, sapply(t_vals, H), type = "l", col = "blue", xlab = "t", ylab = "H(t)",
main = paste("Mother Wavelet and H_n(t) for n = 1 to", n_max))
# Add lines for the wavelets H_n(t) for n = 1 to n_max with different colors and labels
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
wavelet_vals <- sapply(t_vals, H_n, j = j, k = k)
lines(t_vals, wavelet_vals, col = colors[n], lwd = 2)  # Color each wavelet line differently
labels <- c(labels, paste("H_", n, "(t)", sep = ""))  # Add label for each wavelet
}
# Add a legend for the wavelets
legend("topright", legend = labels, col = c("blue", colors), lty = 1, lwd = 2)
}
# Example: Plot H_n(t) for n from 1 to 8 with different colors
plot_wavelets(8)
# Add a legend for the wavelets
legend("topright", legend = labels, col = c("blue", colors), lty = 1, lwd = 2,
xpd = TRUE, inset = c(1.1, 0))  # Adjust inset to move the legend outside}
# Plotting function
plot_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Set up colors (a different color for each wavelet)
colors <- rainbow(n_max) # Generate a set of colors
labels <- c("Mother Wavelet") # Label for the mother wavelet
# Plot the mother wavelet
plot(t_vals, sapply(t_vals, H), type = "l", col = "blue", xlab = "t", ylab = "H(t)",
main = paste("Mother Wavelet and H_n(t) for n = 1 to", n_max))
# Add lines for the wavelets H_n(t) for n = 1 to n_max with different colors and labels
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
wavelet_vals <- sapply(t_vals, H_n, j = j, k = k)
lines(t_vals, wavelet_vals, col = colors[n], lwd = 2)  # Color each wavelet line differently
labels <- c(labels, paste("H_", n, "(t)", sep = ""))  # Add label for each wavelet
}
# Add a legend for the wavelets
legend("topright", legend = labels, col = c("blue", colors), lty = 1, lwd = 2,
xpd = TRUE, inset = c(1.1, 0))  # Adjust inset to move the legend outside
}
# Example: Plot H_n(t) for n from 1 to 8 with different colors
plot_wavelets(8)
library(ggplot2)
library(dplyr)
# Define the "mother wavelet" H(t)
H <- function(t) {
if (t >= 0 && t < 0.5) {
return(1)
} else if (t >= 0.5 && t <= 1) {
return(-1)
} else {
return(0)
}
}
# Define the sequence of functions H_n(t)
H_n <- function(t, j, k) {
return(2^(j/2) * H(2^j * t - k))
}
# Plotting function using ggplot2
plot_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Set up data for the plot
data_list <- list()
# Add the mother wavelet to the data
mother_wavelet <- data.frame(t = t_vals, H_t = sapply(t_vals, H), wavelet = "Mother Wavelet")
data_list[[1]] <- mother_wavelet
# Add the wavelets H_n(t) to the data
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
wavelet_vals <- sapply(t_vals, H_n, j = j, k = k)
wavelet_data <- data.frame(t = t_vals, H_t = wavelet_vals, wavelet = paste("H_", n, "(t)", sep = ""))
data_list[[n + 1]] <- wavelet_data
}
# Combine the data into one data frame
all_data <- bind_rows(data_list)
# Create the ggplot
p <- ggplot(all_data, aes(x = t, y = H_t, color = wavelet, linetype = wavelet)) +
geom_line(size = 1) +
scale_color_manual(values = c("blue", rainbow(n_max))) +  # Set custom colors
labs(title = paste("Mother Wavelet and H_n(t) for n = 1 to", n_max),
x = "t", y = "H(t)", color = "Wavelet") +
theme_minimal() +
theme(legend.position = "top", legend.box = "horizontal", legend.box.spacing = unit(0.5, "cm"))
# Print the plot
print(p)
}
# Example: Plot H_n(t) for n from 1 to 8 with different colors
plot_wavelets(8)
# Example: Plot H_n(t) for n from 1 to 8 with different colors
plot_wavelets(4)
## clear environment (if desired)
rm(list=ls())
library(ggplot2)
library(dplyr)
# Define the "mother wavelet" H(t)
H <- function(t) {
if (t >= 0 && t < 0.5) {
return(1)
} else if (t >= 0.5 && t <= 1) {
return(-1)
} else {
return(0)
}
}
# Define the sequence of functions H_n(t)
H_n <- function(t, j, k) {
return(2^(j/2) * H(2^j * t - k))
}
# Plotting function using ggplot2
plot_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Set up data for the plot
data_list <- list()
# Add the mother wavelet to the data
mother_wavelet <- data.frame(t = t_vals, H_t = sapply(t_vals, H), wavelet = "Mother Wavelet")
data_list[[1]] <- mother_wavelet
# Add the wavelets H_n(t) to the data
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
wavelet_vals <- sapply(t_vals, H_n, j = j, k = k)
wavelet_data <- data.frame(t = t_vals, H_t = wavelet_vals, wavelet = paste("H_", n, "(t)", sep = ""))
data_list[[n + 1]] <- wavelet_data
}
# Combine the data into one data frame
all_data <- bind_rows(data_list)
# Create the ggplot
p <- ggplot(all_data, aes(x = t, y = H_t, color = wavelet, linetype = wavelet)) +
geom_line(size = 1) +
scale_color_manual(values = c("blue", rainbow(n_max))) +  # Set custom colors
labs(title = paste("Mother Wavelet and H_n(t) for n = 1 to", n_max),
x = "t", y = "H(t)", color = "Wavelet") +
theme_minimal() +
theme(legend.position = "top", legend.box = "horizontal", legend.box.spacing = unit(0.5, "cm"))
# Print the plot
print(p)
}
# Example: Plot H_n(t) for n from 1 to 8 with different colors
plot_wavelets(7)
# Define the triangle function Delta(t)
Delta <- function(t) {
if (t >= 0 && t < 0.5) {
return(2 * t)
} else if (t >= 0.5 && t <= 1) {
return(2 * (1 - t))
} else {
return(0)
}
}
# Define the sequence of functions Delta_n(t)
Delta_n <- function(t, j, k) {
ifelse(t==0, return(t), return(Delta(2^j * t - k)))
}
# Plotting function using ggplot2
plot_triangle_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Set up data for the plot
data_list <- list()
# Add the mother wavelet (Delta(t)) to the data--i think mother wavelet is same as delta_1
mother_wavelet <- data.frame(t = t_vals, Delta_t = sapply(t_vals, Delta), wavelet = "Mother Wavelet")
data_list[[1]] <- mother_wavelet
# Add the functions Delta_n(t) for n = 1 to n_max
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
wavelet_vals <- sapply(t_vals, Delta_n, j = j, k = k)
wavelet_data <- data.frame(t = t_vals, Delta_t = wavelet_vals, wavelet = paste("Delta_", n, "(t)", sep = ""))
data_list[[n + 2]] <- wavelet_data
}
# Combine the data into one data frame
all_data <- bind_rows(data_list)
# Create the ggplot
p <- ggplot(all_data, aes(x = t, y = Delta_t, color = wavelet, linetype = wavelet)) +
geom_line(size = 1) +
scale_color_manual(values = c("blue", rainbow(n_max + 1))) +  # Set custom colors (blue for mother wavelet)
labs(title = paste("Delta_n(t) and Mother Wavelet for n = 0 to", n_max),
x = "t", y = "Delta(t)", color = "Wavelet") +
theme_minimal() +
theme(legend.position = "top", legend.box = "horizontal", legend.box.spacing = unit(0.5, "cm"))
# Print the plot
print(p)
}
# Example: Plot Delta_n(t) for n from 0 to 7 with different colors and including the mother wavelet
plot_triangle_wavelets(7)
# Define lambda_n calculation
lambda_n <- function(n) {
if (n == 0) {
return(1)
} else {
j <- floor(log2(n))  # This corresponds to the j value for n = 2^j + k
return(1/2 * 2^(-j/2))
}
}
# Define X_t as the sum of terms for each t
X_t <- function(t, n_max) {
Xt_sum <- 0
for (n in 0:n_max) {
j <- floor(log2(n))
k <- n - 2^j
lambda_n_value <- lambda_n(n)
Z_n <- rnorm(1)  # Generating standard normal random variable
Xt_sum <- Xt_sum + lambda_n_value * Z_n * Delta_n(t, j, k)
}
return(Xt_sum)
}
# Plotting function
plot_X_t <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Compute X_t for each t value
Xt_vals <- sapply(t_vals, X_t, n_max = n_max)
# Create the data frame for ggplot
data <- data.frame(t = t_vals, X_t = Xt_vals)
# Create the ggplot
p <- ggplot(data, aes(x = t, y = X_t)) +
geom_line(size = 1) +
labs(title = paste("X_t for n = 0 to", n_max),
x = "t", y = "X_t") +
theme_minimal()
# Print the plot
print(p)
}
# Example: Plot X_t for n from 0 to 8
plot_X_t(7)
# Plotting function
plot_X_t <- function(n_max) {
t_vals <- seq(0, 1, length.out = 16)
# Compute X_t for each t value
Xt_vals <- sapply(t_vals, X_t, n_max = n_max)
# Create the data frame for ggplot
data <- data.frame(t = t_vals, X_t = Xt_vals)
# Create the ggplot
p <- ggplot(data, aes(x = t, y = X_t)) +
geom_line(size = 1) +
labs(title = paste("X_t for n = 0 to", n_max),
x = "t", y = "X_t") +
theme_minimal()
# Print the plot
print(p)
}
# Example: Plot X_t for n from 0 to 8
plot_X_t(7)
# Plotting function
plot_X_t <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Compute X_t for each t value
Xt_vals <- sapply(t_vals, X_t, n_max = n_max)
# Create the data frame for ggplot
data <- data.frame(t = t_vals, X_t = Xt_vals)
# Create the ggplot
p <- ggplot(data, aes(x = t, y = X_t)) +
geom_line(size = 1) +
labs(title = paste("X_t for n = 0 to", n_max),
x = "t", y = "X_t") +
theme_minimal()
# Print the plot
print(p)
}
# Example: Plot X_t for n from 0 to 8
plot_X_t(7)
# Plotting function using ggplot2
plot_wavelets <- function(n_max) {
t_vals <- seq(0, 1, length.out = 1000)
# Set up data for the plot
data_list <- list()
# Add the mother wavelet to the data
mother_wavelet <- data.frame(t = t_vals, H_t = sapply(t_vals, H), wavelet = "Mother Wavelet")
data_list[[1]] <- mother_wavelet
# Add the wavelets H_n(t) to the data
for (n in 1:n_max) {
j <- floor(log2(n))
k <- n - 2^j
wavelet_vals <- sapply(t_vals, H_n, j = j, k = k)
wavelet_data <- data.frame(t = t_vals, H_t = wavelet_vals, wavelet = paste("H_", n, "(t)", sep = ""))
data_list[[n + 1]] <- wavelet_data
}
# Combine the data into one data frame
all_data <- bind_rows(data_list)
# Create the ggplot
p <- ggplot(all_data, aes(x = t, y = H_t, color = wavelet, linetype = wavelet)) +
geom_line(size = 1) +
scale_color_manual(values = c("blue", rainbow(n_max))) +  # Set custom colors
labs(title = paste("Mother Wavelet and H_n(t) for n = 1 to", n_max),
x = "t", y = "H(t)", color = "Wavelet") +
theme_minimal() +
theme(legend.position = "top", legend.box = "horizontal", legend.box.spacing = unit(0.5, "cm"))
# Print the plot
print(p)
}
# Example: Plot H_n(t) for n from 1 to 8 with different colors
plot_wavelets(3)
p_be <- 11 / 21
z <- qnorm(0.975)
p_values <- seq(p_BE + 1e-4, 1, length.out = 100)
p_values <- seq(p_be + 1e-4, 1, length.out = 100)
n_required <- numeric(length(p_values))
for (i in 1:length(p_values)) {
p <- p_values[i]
num <- z * sqrt(p * (1 - p))
denom <- p - p_BE
n_required[i] <- ceiling((num / denom)^2)
}
for (i in 1:length(p_values)) {
p <- p_values[i]
num <- z * sqrt(p * (1 - p))
denom <- p - p_be
n_required[i] <- ceiling((num / denom)^2)
}
# dataframe for lpotting
plot_data <- data.frame(
p = p_values,
n = n_required
)
ggplot(plot_data, aes(x = p, y = n)) +
geom_line(color = "blue", size = 1) +
geom_vline(xintercept = p_be, linetype = "dashed", color = "red") +
labs(title = "Number of Bets Needed for 95% Confidence of Profitability",
x = "True Success Rate (p)",
y = "Minimum Bets Needed (n)") +
theme_minimal()
# install.packages(c("ggplot2", "tidyverse"))
library(ggplot2)
library(tidyverse)
library(broom)
ggplot(plot_data, aes(x = p, y = n)) +
geom_line(color = "blue", size = 1) +
geom_vline(xintercept = p_be, linetype = "dashed", color = "red") +
labs(title = "Number of Bets Needed for 95% Confidence of Profitability",
x = "True Success Rate (p)",
y = "Minimum Bets Needed (n)") +
theme_minimal()
n_required
View(plot_data)
rm(list=ls())
# install.packages("welo")
library(welo)
library(tidyverse)
library(data.table)
wimbledon_2011 <- as.data.table(read.csv("../data/wimbledon_2011_combined.csv"))
wimbledon_2015 <- as.data.table(read.csv("../data/wimbledon_2015_combined.csv"))
wimbledon_2016 <- as.data.table(read.csv("../data/wimbledon_2016_combined.csv"))
wimbledon_2017 <- as.data.table(read.csv("../data/wimbledon_2017_combined.csv"))
setwd("C:/UPenn/tennis_wsabi/new code")
wimbledon_2011 <- as.data.table(read.csv("../data/wimbledon_2011_combined.csv"))
wimbledon_2012 <- as.data.table(read.csv("../data/wimbledon_2012_combined.csv"))
wimbledon_2013 <- as.data.table(read.csv("../data/wimbledon_2013_combined.csv"))
wimbledon_2014 <- as.data.table(read.csv("../data/wimbledon_2014_combined.csv"))
wimbledon_2015 <- as.data.table(read.csv("../data/wimbledon_2015_combined.csv"))
wimbledon_2016 <- as.data.table(read.csv("../data/wimbledon_2016_combined.csv"))
wimbledon_2017 <- as.data.table(read.csv("../data/wimbledon_2017_combined.csv"))
wimbledon_2018 <- as.data.table(read.csv("../data/wimbledon_2018_combined.csv"))
wimbledon_2019 <- as.data.table(read.csv("../data/wimbledon_2019_combined.csv"))
wimbledon_2021 <- as.data.table(read.csv("../data/wimbledon_2021_combined.csv"))
wimbledon_2022 <- as.data.table(read.csv("../data/wimbledon_2022_combined.csv"))
wimbledon_2023 <- as.data.table(read.csv("../data/wimbledon_2023_combined.csv"))
wimbledon_2024 <- as.data.table(read.csv("../data/wimbledon_2024_combined.csv"))
names(wimbledon_2015)
selected_cols <- c("P1Score", "P2Score", "PointServer", "PointWinner", "GameWinner")
wimbledon_combined <- rbindlist(lapply(
list(wimbledon_2011, wimbledon_2012, wimbledon_2013, wimbledon_2014, wimbledon_2015, wimbledon_2016,
wimbledon_2017, wimbledon_2018, wimbledon_2019, wimbledon_2021, wimbledon_2022, wimbledon_2023, wimbledon_2024),
function(dt) dt[, ..selected_cols]
)) %>%
mutate(
P1Score = as.character(P1Score),
P2Score = as.character(P2Score),
PointServer = as.integer(PointServer),
PointWinner = as.integer(PointWinner),
GameWinner = as.integer(GameWinner),
# server_score = if_else(PointServer == 1, P1Score, P2Score),
# returner_score = if_else(PointServer == 1, P2Score, P1Score),
state = paste(P1Score, P2Score, sep = "-")
) %>%
filter(!is.na(P1Score), !is.na(P2Score), !is.na(PointServer), !is.na(PointWinner), !is.na(GameWinner))
# remove last row in wimbledon_combined
wimbledon_combined <- wimbledon_combined[-nrow(wimbledon_combined), ]
# Prepare and clean the data
df <- wimbledon_combined %>%
mutate(
server_won_point = if_else((PointServer == 1 & PointWinner == 1) |
(PointServer == 2 & PointWinner == 2), TRUE, FALSE),
game_winner_is_server = if_else((PointServer == 1 & GameWinner == 1) |
(PointServer == 2 & GameWinner == 2), 1, 0)
) %>%
filter(state %in% c("0-0", "15-0", "30-0", "40-0",
"0-15", "0-30", "0-40",
"15-15", "30-15", "40-15",
"15-30", "30-30", "40-30",
"15-40", "30-40", "40-40",
"40-AD", "AD-40"))
# Step 1: Add a unique game ID (based on runs of "0-0" score)
df <- df %>%
mutate(new_game = (state == "0-0")) %>%
mutate(game_id = cumsum(new_game))
# Step 2: Create a lookup table with the GameWinner for each game_id
game_winners <- df %>%
filter(state == "0-0") %>%
select(game_id, GameWinner)
# Shift GameWinner up by one row (so it applies to the previous game)
game_winners <- game_winners %>%
mutate(GameWinner = lead(GameWinner))
# player 1 won the last game (from wimbledon_combined before removoing last row)
game_winners[nrow(game_winners), "GameWinner"] <- 1
# Step 3: Join back to assign GameWinner to all points in the same game
df <- df %>%
select(-GameWinner) %>%  # remove old GameWinner (0s)
left_join(game_winners, by = "game_id")  # assign correct GameWinner
df <- df %>%
mutate(
game_winner_is_server = if_else((PointServer == 1 & GameWinner == 1) |
(PointServer == 2 & GameWinner == 2), 1, 0)
)
df <- df %>%
filter(PointServer %in% c(1, 2))
# Get all transitions where the current score is known
# and filter where the server had a chance to win
df_scores <- df %>%
filter(!is.na(state)) %>%
group_by(state, server_won_point) %>%
summarise(
n = n(),
server_win_game = sum(game_winner_is_server, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(prob_win_game = server_win_game / n)
View(df)
View(df_scores)
View(df_scores)
